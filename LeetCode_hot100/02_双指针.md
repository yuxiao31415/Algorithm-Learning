# hot100 - - 双指针
## 4. 移动零
``` java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow= 0;
        for(int fast=0;fast<nums.length;fast++){
            if(nums[fast]!=0){
                int tmp=nums[fast]; // 必须用tmp记录,先将fast置为零;再将slow置为原本的fast值,避免fast覆盖
                nums[fast]=0;
                nums[slow]=tmp;
                slow++;
            }
        }
    }
}
```
### 思路
* 慢指针:要覆盖的位置  
* 快指针:非零的位置,走过的地方都置为零  
* 不断交换值  
### 位置  
https://leetcode.cn/problems/move-zeroes/description/?envType=study-plan-v2&envId=top-100-liked  

## 5.  盛最多水的容器
```java
class Solution {
    public int maxArea(int[] height) {
        int l =0;
        int r = height.length-1;
        int ans = 0;
        while(l<r){
            ans = height[l]>height[r]?
            Math.max(ans,(r-l)*height[r--]):
            Math.max(ans,(r-l)*height[l++]);
        }
        return ans;
    }
}
```
### 思路  
* 决定盛水多少是由短的那根木板决定  
* 所以可以根据短的那根木板来移动  
* 使用__双指针__
### 总结  
```java
 ans = height[l]>height[r]?
            Math.max(ans,(r-l)*height[r--]):
            Math.max(ans,(r-l)*height[l++]);
```
这个写法简洁明了
### 位置  
https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-100-liked  

## 6. 三数之和 
``` java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<>();
        for(int i = 0;i<nums.length-2;i++){
            if(nums[i]>0){break;}
            if(i>0&&nums[i]==nums[i-1]) continue; // 第一个注意点
            int l=i+1;
            int r = nums.length-1;
            while(l<r){
                if(nums[i]+nums[l]+nums[r]<0){
                    while(l<r && nums[l]==nums[++l]); // 第二个注意点 
                }else if(nums[i]+nums[l]+nums[r]>0){
                    while(l<r && nums[r]==nums[--r]);
                }else{
                    // ans.add(Arrays.asList(nums[i],nums[l],nums[r])); // 第三个注意点
                    ans.add(new ArrayList<>(Arrays.asList(nums[i],nums[l],nums[r])));
                    while(l<r && nums[l]==nums[++l]);
                    while(l<r && nums[r]==nums[--r]);
                }
            }
        }
        return ans;
    }
}
``` 
### 思路   
先排序得到升序的数组  
从左往右遍历数组(相当于每次都固定了一个值,找到另外两个值和为目标值 )  
剩下的两个值通过双指针来找  
__注意__:  因为结果不能包含重复元素 所以第一个值遍历时,还有另外两个值遍历时 需要去重  
### 总结  
 总结 1. 要求不重复 所以`` i,j`` 得去重   
​    2. ``while(l<r&&nums[r]==nums[--r])`` 学会这种写法 找到下一个不与之前值相等的位置;  
3. ``ans: List<List<Integer>>``  所以得``add``一个``List<Integer> ``  
​                 ``Arrays.asList(1, 2, 3, 4);``  
​                  和 ``new ArrayList<>((Arrays.asList(1, 2, 3, 4))``  
​                  返回的``ArrayList``不是同一个类   
​                 ``Arrays.asList() ``返回的类名：``java.util.Arrays$ArrayList``  
​                 ``new ArrayList() ``得到的类名：``java.util.ArrayList ``  
### 位置  
https://leetcode.cn/problems/3sum/description/?envType=study-plan-v2&envId=top-100-liked  
## 7. 接雨水  
``` java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        // 左边高度序列
        int[] l = new int[n];
        l[0] = height[0];
        for(int i =1;i<n;i++){
            l[i] = Math.max(height[i],l[i-1]);
        }
        // 右边高度序列
        int[] r = new int[n];
        r[n-1] = height[n-1];
        for(int i =n-2;i>0;i--){
            r[i] = Math.max(height[i],r[i+1]);
        }
        // 计算答案
        int ans =0;
        for(int i =0;i<n;i++){
            int x = Math.min(r[i],l[i])-height[i]; // 最关键的地方
            ans+=x>0?x:0;   // 不要忘记判断
        }
        return ans;
    }
}
```
### 思路
关键在就在于:每一列容量==左右最短的高度-本身高度  
__注意:__排除负值  
### 位置  
https://leetcode.cn/problems/trapping-rain-water/submissions/696586706/?envType=study-plan-v2&envId=top-100-liked 
