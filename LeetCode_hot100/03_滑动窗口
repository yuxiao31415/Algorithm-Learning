# 滑动窗口
## 8.无重复字符的最长子串  
``` java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int ans =0;
        int left =0;
        Map<Character,Integer> map = new HashMap<>();
        char[] chars = s.toCharArray();
        for(int i=0;i<chars.length;i++){
            map.merge(chars[i],1,Integer::sum);
            while(map.get(chars[i])>1){
                map.put(chars[left],map.get(chars[left])-1);
                left++;
            }
            ans = Math.max(ans,i-left+1);
        }
        return ans;
    }
}
```
### 思路  
使用滑动窗口,左边不动,右边不断遍历,用一个``HashMap<Character,Integer>``存储元素出现个数  
如果当前元素出现个数大于了1就表明 有重复元素,  
然后左端点不断移动 将``HashMap``的值-- 直到这个元素的个数等于一 继续右端点移动  
### 总结 
``map.merge(chars[i],1,Integer::sum);`` 若不包含``chars[i]``,则values=``1``,若包含则 ``新values``为``values``与``1``求和  
### 位置  
https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-100-liked  

## 9.找到字符串所有字母异位词
``` java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        int[] cntP = new int[26];
        int[] cntS = new int[26];
        List<Integer> ans = new ArrayList<>();
        for(char c:p.toCharArray()){
            cntP[c-'a']++;
        }
        for(int right=0;right<s.length();right++){
            cntS[s.charAt(right)-'a']++;
            int left = right-p.length()+1;
            if(left<0){continue;}
            if(Arrays.equals(cntS,cntP)){
                ans.add(left);
            }
            cntS[s.charAt(left)-'a']--;
        }
        return ans;
    }
}
```
### 思路
字母异位词的判断方式有两种  
1. 用``int[26]``记录每个字母出现次数,若``Arrays.equals(cntS,cntP)``则为异位词  
2. 将异位词重排: ``char[] cs = s.toCharArray()`` ``Arrays.sort(cs)`` 若重排后相等则为异位词  
本题若用方法二则需要从s中分割出来判断,比较麻烦,最好使用方法一  
通过滑动窗口不断移动 右进左出
### 总结 
```java
int[] cntP = new int[26];        
for(char c:p.toCharArray()){
            cntP[c-'a']++;
}// 方法一常规流程 统计各个字母出现个数
```
### 位置  
https://leetcode.cn/problems/find-all-anagrams-in-a-string/?envType=study-plan-v2&envId=top-100-liked  
