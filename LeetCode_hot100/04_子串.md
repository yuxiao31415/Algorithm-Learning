# 子串
## 10.和为k的子数组
``` java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int n = nums.length;
        int[] s = new int[n + 1];
        for (int i = 0; i < n; i++) {
            s[i + 1] = s[i] + nums[i];
        }

        int ans = 0;
        Map<Integer, Integer> cnt = new HashMap<>(n + 1, 1); // 预分配空间 避免频繁扩容,1为负载因子
        for (int sj : s) {
            ans += cnt.getOrDefault(sj - k, 0);
            cnt.merge(sj, 1, Integer::sum); // cnt[sj]++
        }
        return ans;
    }
}

```
### 思路
此题不能使用滑动窗口,因为滑动窗口需要元素值单调,比如[1,2,3,4];也不能直接使用__<<1.两数之和>>__的方式硬求,因为题目要求连续子数组  
本题最优解为__前缀和__  
将数组转换为前缀和之后就能把连续子数组转换为任意两元素问题(__<<1.两数之和>>__)  
### 总结  
```java
int[] s = new int[n + 1];
for (int i = 0; i < n; i++) {
    s[i + 1] = s[i] + nums[i];
} // 前缀和标准模板,注意第一个元素为零
```
计算完前缀和之后,第``m``与第``n``个元素的差为``k``表示``(n,m]``或者``[n+1,m]``的和为``k`` 
### 位置
https://leetcode.cn/problems/subarray-sum-equals-k/?envType=study-plan-v2&envId=top-100-liked  

## 11.滑动窗口最大值
``` java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> deque = new ArrayDeque<>();// 注意不能使用Queue来接受deque 因为像xxFirst等方法Queue中没有
        int n=nums.length;
        int[] ans = new int[n-k+1];
        for(int i=0;i<n;i++){
            // 先判断条件一 当前队列头是否在[i-k+1,i]中
            while(!deque.isEmpty()&& deque.peekFirst()<i-k+1){
                deque.pollFirst();
            }
            // 判断条件二 维护单调减队列,当前元素是否小于队尾元素
            while(!deque.isEmpty()&&nums[i]>nums[deque.peekLast()]){
                deque.pollLast();
            }
            deque.offerLast(i);
            if(i-k+1>=0){
                ans[i-k+1]=nums[deque.peekFirst()];
            }
        }
        return ans;
    }
}
```
### 思路
定义一个单调递减的队列(头节点大,尾结点小):  
1. 第一点,元素索引必须要在``[i-k+1,i]``中,如果不在则弹出;  
2. 第二点,当前元素与队尾元素比较,若小于则放入队尾,若大于则弹出队尾,不断循环  
使用双端序列来实现这个单调减的队列,队列的值为索引值,方便第一条判断  
### 总结  
```java
Deque<Integer> deque = new ArrayDeque<>();
// 添加元素
addFirst(E e); //队列头插入元素,若队列已满则抛出异常
addLast(E e); //队列尾插入元素,若队列已满则抛出异常
offerFirst(E e);// 队列头插入元素,成功返回true,失败返回false
offerLast(E e); //队列尾插入元素,成功返回true,失败返回false
// 删除元素
removeFirst();//移除并返回头部元素，若队列为空则抛出异常
removeLast();//移除并返回尾部元素，若队列为空则抛出异常
pollFirst();//移除并返回头部元素，若队列为空则返回null
pollLast();//移除并返回尾部元素，若队列为空则返回null
//访问元素
getFirst();//获取头部元素（不删除），若队列为空则抛出异常
getLast();//获取头部元素（不删除），若队列为空则抛出异常
peekFirst();//获取头部元素（不删除），若队列为空则返回null
peekLast();//获取头部元素（不删除），若队列为空则返回null

peek poll offer
```
### 位置
https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked   

## 12.最小覆盖子串

``` java
class Solution {
    public String minWindow(String s, String t) {
        int[] cntT = new int[128];
        int[] cntS = new int[128];
        int left =0;
        int ansLeft =-1;
        int ansRight =s.length()-1;
        for(char c:t.toCharArray()){
            cntT[c]++;
        }
        for(int right=0;right<s.length();right++){
            cntS[s.charAt(right)]++;
            while(isCovered(cntS,cntT)){
                if(right-left<ansRight-ansLeft){
                    ansRight = right;
                    ansLeft = left;
                }
                cntS[s.charAt(left++)]--;
            }
        }
        return ansLeft < 0 ? "" : s.substring(ansLeft, ansRight + 1);

    }
    private boolean isCovered(int[] cntS,int[] cntT){
        for(int i=0;i<cntS.length;i++){
            if(cntS[i]<cntT[i]){return false;}
        }
        return true;
    }
}
```
### 思路
本题完全与__<<9.找到字符串所有字母异位词>>__思路一致  
右端点遍历数组,定义一个函数来判断是否覆盖``isCovered()``,若覆盖则不断调整左端点,直到不覆盖然后移动右端点  
__关键点__: 因为结果需要输出 字符串,所以需要额外两个空间来存储字符串左右索引  
### 总结  
1. ``s.charAt(right)``  
2. ``ascii``码表中``A:65-Z:90 a:97-z:122``  
### 位置
https://leetcode.cn/problems/minimum-window-substring/description/?envType=study-plan-v2&envId=top-100-liked
