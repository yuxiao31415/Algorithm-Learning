# 数组
## 13.最大数组和
``` java
class Solution {
    public int maxSubArray(int[] nums) {
        int preSum =0;
        int ans =Integer.MIN_VALUE;
        int minpreSum = 0;
        for(int num:nums){
            preSum += num;
            ans = Math.max(ans,preSum-minpreSum);
            minpreSum = Math.min(minpreSum,preSum);
        }
        return ans;
    }
}
```
### 思路
计算连续数组的和，需要计算数组的__前缀和__从而将连续转为任意位置
### 位置
https://leetcode.cn/problems/maximum-subarray/description/?envType=study-plan-v2&envId=top-100-liked  
## 14.合并区间
``` java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals,(p,q) -> p[0]-q[0]);
        List<int[]> ans = new ArrayList<>();
        for(int[] p:intervals){
            int m =ans.size();
            if(m>0&&p[0]<=ans.get(m-1)[1]){
                ans.get(m-1)[1]=Math.max(ans.get(m-1)[1],p[1]);
            }else{
                ans.add(p);
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```
### 思路
### 总结 
```return ans.toArray(new int[ans.size()][]);``` ```toArray()```需要传入一个```int[][]`` 数组来接收结果
### 位置
https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked  
## 15.轮转数组#
``` java
class Solution {
    public void rotate(int[] nums, int k) {
        k %= nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    public void reverse(int[] nums,int start,int end){
        int left =start;
        int right = end;
        while(left<right){
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            left++;
            right--;
        }
    }
}
```
### 思路
1.轮转k位置(```A=[1,2,3,4,5,6];B=[7,8,9]```) ```A+B = [1,2,3,4,5,6]+[7,8,9]```  
反转为```B+A=[7,8,9]+[1,2,3,4,5,6]```就相当于整体反转一次,```A```反转一次,```B```反转一次
### 位置
https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked

## 16.除自身以外数组的乘积

``` java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] leftMul= new int[nums.length];
        leftMul[0]=1;
        for(int i=1;i<nums.length;i++){
            leftMul[i] =leftMul[i-1]*nums[i-1];
        }

        int[]  rightMul=new int[nums.length]; 
        rightMul[nums.length-1]=1;
        for(int i=nums.length-1-1;i>=0;i--){
            rightMul[i] =rightMul[i+1]*nums[i+1];
        }

        int[] ans = new int[nums.length];
        for(int i=0;i<nums.length;i++){
            ans[i] = leftMul[i]*rightMul[i];
        }
        return ans;            
    }
}
```
### 思路
使用类似前缀和的思想,用一个数组存放自身左侧数值的乘积,  
再用另一个数组存放自身数值右侧的乘积(```left[0]=1,right[n-1] = 1```)  
数组对应元素相乘即为最终结果  
### 位置
https://leetcode.cn/problems/product-of-array-except-self/description/?envType=study-plan-v2&envId=top-100-liked  
## 17.缺失的第一个正数##
``` java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n=nums.length;
        for(int i =0;i<n;i++){
            while(1<=nums[i] && nums[i]<=n &&nums[i]!=nums[nums[i]-1]){ // nums[i]!=nums[nums[i]-1]:当前位置与要换的位置的元素值不能相同
                                                                        // 不必担心无限循环,如果缺少了当前位置需要的元素,那么不断交换终会拿到1<=nums[i] && nums[i]<=n 不满足这个条件的值
                int j=nums[i]-1;
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
            }
        }
        for(int i = 0;i<n;i++){
            if(nums[i]!=i+1){
                return i+1;
            }
        }
        return n+1;
    }
}
```
### 思路
解题步骤:
___换座位___:不需要满足数值在```[1,n+1]```的范围内  
有 n 个学生坐在教室的座位上，把 ```nums[i]```当作坐在第 i 个座位上的学生的学号。  
我们要做的事情，就是让学号在 1 到 n 中的学生，都坐到编号与自己学号相同的座位上（学号与座位编号匹配）。  
学号不在``` [1,n] ```中的学生可以忽略  
### 总结
```java
while(1<=nums[i] && nums[i]<=n &&nums[i]!=nums[nums[i]-1])
// 1 nums[0],2 nums[1],i nums[i-1]
//1.不在[1,n]中的学生可以忽略
//2.nums[i]!=nums[nums[i]-1] 而不是i!=nums[i]-1可以避免重复元素如[1,1,2]
//当i = 1时,i!=nums[i]-1 需要交换元素,从而无限循环
//而nums[i]==nums[nums[i]-1] 跳过这次循环
```
### 位置
https://leetcode.cn/problems/first-missing-positive/?envType=study-plan-v2&envId=top-100-liked
