## 18.矩阵置零  
```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int m=matrix.length,n=matrix[0].length;
        boolean flagCol0 = false,flagRow0=false;
        // 判断第一行是否有零值
        for(int i=0;i<n;i++){
            if(matrix[0][i]==0){
                flagCol0=true;
            }
        }
        // 判断第一列是否有零值
        for(int i=0;i<m;i++){
            if(matrix[i][0]==0){
                flagRow0=true;
            }
        }
        //第一行第一列用来记录内部是否有零
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(matrix[i][j]==0){
                    matrix[i][0]=matrix[0][j]=0;
                }
            }
        }
        // 根据第一行第一列置零 必须从1,1开始 不能是0,0开始**
        for(int i=1;i<m;i++){
            for(int j =1;j<n;j++){
                if(matrix[i][0]==0||matrix[0][j]==0){
                    matrix[i][j]=0;
                }
            }
        }
        //根据标记为置零
        if(flagCol0){
            for (int i = 0; i < n; i++) {
                matrix[0][i] = 0;
            }
        }
        if(flagRow0){
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }

```
### 思路
1. 用第一行以及第一列来记录某行或者列中是否有0值  
2. 但是会丢失原本第一行第一列是否有0值的信息  
3. 用一个布尔值flagRow来表示行是否有零值,第一列是否有零值的信息包含在第一列的记录中  
4. 用两个布尔值flagRow,flagCol来记录分别记录第一行与第一列,这样做的好处是对称(上述解法采用了这种方案)  

### 位置
[73. 矩阵置零 - 力扣（LeetCode）](https://leetcode.cn/problems/set-matrix-zeroes/description/?envType=study-plan-v2&envId=top-100-liked)

## 19.螺旋矩阵#
```java
class Solution {
    //定义移动方向(行列坐标的变化)
    private final int[][] DIRS = {{0,1},{1,0},{0,-1},{-1,0}};
    public List<Integer> spiralOrder(int[][] matrix) {
        int m= matrix.length;
        int n = matrix[0].length;
        int size =m*n;
        List<Integer> ans =new ArrayList<>(size);
        int i=0;
        int j=-1;
        for(int dis =0;ans.size()<size;dis=(dis+1)%4){
            for(int k=0;k<n;k++){
                i+=DIRS[dis][0];
                j+=DIRS[dis][1];
                ans.add(matrix[i][j]);
            }
            int tmp =n;
            n=m-1;
            m = tmp; 
        }
        return ans;
    }
}
```

### 思路 

```java
private final int[][] DIRS = {{0,1},{1,0},{0,-1},{-1,0}};
// 定义移动方向,通过DIRS[dis]来选择使用哪个方向;通过DIRS[dis][0]/[1]来决定作为x还是y移动
```
### 位置  
[54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/description/?envType=study-plan-v2&envId=top-100-liked)

## **螺旋矩阵II

```java

```
### 思路  
同螺旋矩阵I  
### 位置
[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)
## 20.旋转图像
```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for(int i =0;i<n;i++){
            int[] row = matrix[i];
            for(int j=i+1;j<n;j++){
                int tmp = row[j];
                row[j] = matrix[j][i];
                matrix[j][i] = tmp;
            }
            for(int j = 0;j<n/2;j++){
                int tmp = row[j];
                row[j] = row[n-1-j];
                row[n-1-j] = tmp;
            }
        }

    }
}
```
### 思路  
旋转90度==转置+行反转  
1. 单独观察第一列,转置变成第一行  
2. 然后对第一行进行反转,得到结果  
3. 所以可以写在一个for内  
### 位置
[48. 旋转图像 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&envId=top-100-liked)
## 21.搜索二维矩阵II
```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int i =0;
        int j = matrix[0].length-1;
        while(i<matrix.length&&j>=0){
            if(matrix[i][j]==target){
                return true;
            }else if(matrix[i][j]>target){
                j--;
            }else{
                i++;
            }
        }
        return false;
    }
}
```
### 思路
1. 定义起始点,右上角```matrix[0][n-1]```  
2. 比较target与这个点的大小:若小于起始点,则n-1再减去1;若大于,则0+1;若等于则返回true  
3. 遍历结束返回false（说明没有遍历到相等的值返回true）   
### 位置
[240. 搜索二维矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/?envType=study-plan-v2&envId=top-100-liked)  
