# hot100 - - 哈希
## 1.两数之和
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer,Integer> map = new HashMap<>();
        for(int i = 0;i<nums.length;i++){
            if(map.containsKey(target-nums[i])){
                return new int[]{i,map.get(target-nums[i])};
            }
            map.put(nums[i],i);
        }
        return null;
    }
}
```
### 思路
``HashMap``的优势：可以把 "任意对象" 当作 key 来查找 value,  
数组的限制：索引必须是整数，且连续，从 0 开始  
本题本质就在于把值当做``'索引'(key)``来找索引  
__注意:__``HashMap+for``遍历的这种方式只能处理 任意两数之和 如果题目要求处理连续的两数之和,则不能使用;  
### 总结  
1. ``HashMap``的使用  
   * `map.containsKey()` 判断是否包含某个key  
   * `map.get(key) `获取key对应的value,__注意必须保证存在key__ 否则报错  
2. 返回结果技巧  
* `new int[]{i,j}` 直接写出这个类的结果  
3. for外面可以不加return  
### 位置  
https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked  

## 2.字母异位词分组
```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        //分析:1.每一种字母异位词对应一个数组(排序)
        //     2.遍历strs 如果发现是对应的字母异位词则添加到数组中
        Map<String,List<String>> map = new HashMap<>();
        for(String str:strs){
            char[] chars = str.toCharArray();
            Arrays.sort(chars);
            String sortedStr = new String(chars);

            if(!map.containsKey(sortedStr)){
                map.put(sortedStr,new ArrayList<>());
            }
            map.get(sortedStr).add(str);
        }
        return new ArrayList<>(map.values());
    }
}
// 计数的方法太复杂
```
### 思路
* 遍历全部的``strs`` 找到他们之间的共性作为key(本题中所有字母异位词排序后一致) 放入``HashMap`` 中
### 总结
1. `String` 转 `char[]: char[] cs = s.toCharArray()`;
2. `char[]` 转 `String: String s = new String(char[])`;
3. `Arrays.sort()` 方法,对任何数组进行排序;
4. `Collections.sort()` 方法,对List集合类进行排序
5. 返回技巧: `return new ArrayList<>(map.values())` __注意:`map.values()`返回的是一个视图,不可修改__
### 位置 
https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked  
## 3. 最长连续序列  
```java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> set = new HashSet<>();
        int ans =0;
        for(int i:nums){
            set.add(i);
        }
        for(int i:set){
            if(!set.contains(i-1)){
                int tmp = 1;
                while(set.contains(i+1)){
                    tmp+=1;
                    i++;
                }
                ans = Math.max(ans,tmp);
            }

        }
        return ans;
    }
}
```
### 思路  
* 定义一个``HashSet``(值,索引) 然后遍历找到全部起点(不包含左边值 但包含右边值)
* 通过``HashSet``判断是否有这个数 ``tmp``计数; 
### 位置  
https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked 
