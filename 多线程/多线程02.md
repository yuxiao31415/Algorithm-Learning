**题目: 1115.交替打印 FooBar**  
**位置:**  https://leetcode.cn/problems/print-foobar-alternately/description/  
**题目解读:**  保证是运行完一个在运行另一个,这样交替的
**方法一 lock锁**  
```java
class FooBar {
    private int n;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();
    private boolean fooTurn = true;

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            lock.lock();
            try {
                while (!fooTurn) {
                    condition.await();
                }
                printFoo.run();
                fooTurn = false;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            lock.lock();
            try {
                while (fooTurn) {
                    condition.await();
                }
                printBar.run();
                fooTurn = true;
                condition.signalAll();
            } finally {
                lock.unlock();
            }
        }
    }
}
```
**方法二: semaphore信号量**
```java
import java.util.concurrent.Semaphore;

class FooBar {
    private int n;
    private Semaphore fooSem = new Semaphore(1);
    private Semaphore barSem = new Semaphore(0);

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            fooSem.acquire();
            printFoo.run();
            barSem.release();
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            barSem.acquire();
            printBar.run();
            fooSem.release();
        }
    }
}
```
**方法三:  CountDownLatch(减法计数器)**  
```java
该方法不适用,只能减不能加
```
**方法四:  阻塞队列**  
```java
import java.util.concurrent.SynchronousQueue;

class FooBar {
    private int n;
    private SynchronousQueue<Integer> fooQueue = new SynchronousQueue<>();
    private SynchronousQueue<Integer> barQueue = new SynchronousQueue<>();

    public FooBar(int n) {
        this.n = n;
    }

    public void foo(Runnable printFoo) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            printFoo.run();
            fooQueue.put(1);   // 通知 bar
            barQueue.take();   // 等待 bar 完成
        }
    }

    public void bar(Runnable printBar) throws InterruptedException {
        for (int i = 0; i < n; i++) {
            fooQueue.take();   // 等待 foo
            printBar.run();
            barQueue.put(1);   // 通知 foo
        }
    }
}

```
